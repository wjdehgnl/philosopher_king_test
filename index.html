<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>철인지수 성향테스트</title>
    <style>
        /* 기본 설정 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SUIT Variable', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: #f5f5f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 390px;
            min-height: 844px;
            height: 844px;
            background-color: white;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .screen {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            position: relative;
        }

        /* 홈 화면 */
        .home-screen {
            display: flex;
        }

        .logo {
            margin-bottom: 40px;
            text-align: center;
        }

        .logo h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
            color: #333;
        }

        .logo p {
            font-size: 16px;
            color: #666;
            margin-bottom: 20px;
        }

        .personality-icon {
            width: 200px;
            height: 200px;
            margin: 0 auto 40px;
            background: linear-gradient(45deg, #d30000, #FF3C43, #FF7719);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .personality-icon::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(0,0,0,0.2) 100%);
        }

        .personality-icon-text {
            font-size: 48px;
            font-weight: 900;
            color: white;
            z-index: 1;
        }

        .start-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 300px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .btn-primary {
            background-color: #d30000;
            color: white;
        }

        .btn-primary:hover {
            background-color: #b50000;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: white;
            color: #666;
            border: 1px solid #ddd;
        }

        .btn-secondary:hover {
            background-color: #f8f8f8;
        }

        /* 테스트 화면 */
        .test-screen {
            display: none;
            padding: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #d30000, #FF3C43, #FF7719);
            border-radius: 3px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
        }

        .question-container {
            text-align: center;
            margin-bottom: 40px;
        }

        .question-number {
            font-size: 14px;
            color: #999;
            margin-bottom: 10px;
        }

        .question-text {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            line-height: 1.4;
            margin-bottom: 30px;
        }

        .options-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 40px;
        }

        .option-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: #999;
        }

        .option-btn:hover {
            border-color: #d30000;
            transform: scale(1.05);
        }

        .option-btn.selected {
            background-color: #333;
            border-color: #333;
            color: white;
        }

        .option-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
            padding: 0 20px;
        }

        .questions-container {
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            width: 100%;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .questions-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .question-item {
            margin-bottom: 50px;
            opacity: 1;
            transition: all 0.5s ease;
        }

        .question-item:last-child {
            margin-bottom: 80px;
        }

        .question-item.answered {
            opacity: 0.6;
        }

        /* 결과 화면 */
        .result-screen {
            display: none;
            padding: 20px;
            text-align: center;
        }

        .result-title {
            font-size: 24px;
            font-weight: 700;
            color: #333;
            margin-bottom: 20px;
        }

        .personality-code {
            font-size: 48px;
            font-weight: 900;
            color: #d30000;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        .trait-bars {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 40px;
        }

        .trait-bar {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .trait-labels {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }

        .bar-container {
            position: relative;
            height: 40px;
            background-color: #f0f0f0;
            border-radius: 20px;
            overflow: hidden;
        }

        .bar-segments {
            display: flex;
            height: 100%;
            position: relative;
        }

        .bar-segment {
            flex: 1;
            position: relative;
        }

        .bar-segment:first-child .segment-fill { background-color: #ff4757; }
        .bar-segment:nth-child(2) .segment-fill { background-color: #ff6b7a; }
        .bar-segment:nth-child(3) .segment-fill { background-color: #ff8f9c; }
        .bar-segment:nth-child(4) .segment-fill { background-color: #74b9ff; }
        .bar-segment:nth-child(5) .segment-fill { background-color: #0984e3; }
        .bar-segment:nth-child(6) .segment-fill { background-color: #2d3436; }

        .segment-fill {
            width: 0%;
            height: 100%;
            transition: width 1s ease;
        }

        .bar-center {
            position: absolute;
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: #333;
            transform: translateX(-50%);
            z-index: 10;
        }



        .share-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 30px;
        }

        /* 숨김/표시 클래스 */
        .hidden { 
            display: none !important; 
            visibility: hidden;
            opacity: 0;
        }
        .show { 
            display: flex !important; 
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 홈 화면 -->
        <div class="screen home-screen" id="homeScreen">
            <div class="logo">
                <h1>철인지수 테스트</h1>
                <p>나의 철인지수는 어떨까? 지금 철인지수 테스트 해보기</p>
            </div>
            
            <div class="personality-icon">
                <div class="personality-icon-text">철</div>
            </div>
            
            <div class="start-buttons">
                <button class="btn btn-primary" onclick="startTest()">테스트 시작하기</button>
                
                <!-- 개발용 테스트 기능 시작 -->
                <button class="btn btn-primary" onclick="showRandomResult()" style="background-color: #FF7719;">결과테스트</button>
                <!-- 개발용 테스트 기능 끝 -->
                
                <button class="btn btn-secondary" onclick="shareKakaoTalk()">카카오톡 공유하기</button>
                <button class="btn btn-secondary" onclick="shareLink()">링크 공유하기</button>
            </div>
        </div>

        <!-- 테스트 화면 -->
        <div class="screen test-screen" id="testScreen">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">1 / 20</div>
            
            <div class="questions-container" id="questionsContainer">
                <!-- 질문들이 동적으로 추가됩니다 -->
            </div>
        </div>

        <!-- 결과 화면 -->
        <div class="screen result-screen" id="resultScreen">
            <div class="result-title">당신의 철인지수는</div>
            <div class="personality-code" id="personalityCode">MJHK</div>
            
            <div class="trait-bars" id="traitBars">
                <!-- 성향바들이 동적으로 생성됩니다 -->
            </div>
            
            <div class="share-buttons">
                <button class="btn btn-primary" onclick="restartTest()">다시 테스트하기</button>
                <button class="btn btn-secondary" onclick="shareKakaoTalk()">카카오톡 공유하기</button>
                <button class="btn btn-secondary" onclick="shareLink()">링크 공유하기</button>
            </div>
        </div>
    </div>

    <script>
        // 테스트 설정
        const testConfig = {
            questions: [
                // 도덕심 (M - Morality)
                { text: "선배의 잘못을 보고도 침묵하며 넘어가는 것이 현명하다고 생각한다.", category: 0 },
                { text: "내가 하는 일에서 신념과 원칙은 타협할 수 없는 부분이다.", category: 0 },
                { text: "법적으로는 문제가 없어도 도덕적으로 옳지 않다면 하지 않는다.", category: 0 },
                { text: "다수를 위해서는 소수의 희생이 불가피한 경우가 있다고 생각한다.", category: 0 },
                { text: "올바른 일이라고 판단되면 혼자서라도 행동에 나선다.", category: 0 },
                { text: "소신보다는 현실적 타협이 더 효과적인 해결책이라고 본다.", category: 0 },
                { text: "정당하지 못한 일이라도 결과가 좋으면 용인할 수 있다.", category: 0 },
                { text: "개인의 이익보다는 집단의 이익을 우선시해야 한다.", category: 0 },
                { text: "내 양심에 거슬리는 일은 절대 하지 않는다.", category: 0 },
                { text: "때로는 상황에 따라 거짓말도 필요하다고 생각한다.", category: 0 },
                { text: "나는 새로운 사람들과 만나는 것을 좋아한다.", category: 0 },
                { text: "나는 계획보다는 즉흥적으로 행동하는 편이다.", category: 0 },
                { text: "나는 논리보다는 감정을 중시한다.", category: 0 },
                { text: "나는 마감시간을 잘 지키는 편이다.", category: 0 },
                { text: "옳지 않다고 생각하는 일에는 단호하게 반대한다.", category: 0 },
                { text: "원칙과 신념을 지키는 것이 손해를 보더라도 중요하다.", category: 0 },
                { text: "불의를 보면 그냥 지나치지 못한다.", category: 0 },
                { text: "내 이익을 위해서라도 원칙을 굽히지 않는다.", category: 0 },
                { text: "도덕적 가치는 개인적 성공보다 우선한다.", category: 0 },
                { text: "옳다고 믿는 일은 주위의 반대가 있어도 밀고 나간다.", category: 0 },

                // 적시판단 (J - Judgment)
                { text: "상황에 따라 융통성 있게 행동하는 것이 중요하다.", category: 1 },
                { text: "매사에 신중하게 고민하고 결정하는 편이다.", category: 1 },
                { text: "복잡한 상황에서는 빠른 결정보다는 충분한 검토가 필요하다.", category: 1 },
                { text: "위기상황에서는 직감적 판단이 더 효과적이다.", category: 1 },
                { text: "새로운 정보가 생기면 기존 판단을 번복할 수 있다.", category: 1 },
                { text: "중요한 결정은 혼자보다는 여러 사람과 상의해서 한다.", category: 1 },
                { text: "정답이 없는 문제에서는 과감한 선택이 필요하다.", category: 1 },
                { text: "상황 변화에 따라 전략을 수정하는 것은 당연하다.", category: 1 },
                { text: "확신이 서지 않으면 결정을 미루는 편이다.", category: 1 },
                { text: "경험과 직관을 바탕으로 한 판단을 신뢰한다.", category: 1 },
                { text: "모든 정보를 충분히 검토한 후 결정한다.", category: 1 },
                { text: "급한 상황에서도 침착함을 유지한다.", category: 1 },
                { text: "복잡한 문제는 단계별로 나누어 해결한다.", category: 1 },
                { text: "실수를 줄이기 위해 여러 번 점검한다.", category: 1 },
                { text: "새로운 방법보다는 검증된 방법을 선호한다.", category: 1 },
                { text: "중요한 결정을 앞두고는 신중하게 검토한다.", category: 1 },
                { text: "다양한 관점에서 문제를 바라본다.", category: 1 },
                { text: "감정적 판단보다는 객관적 분석을 중시한다.", category: 1 },
                { text: "시간이 걸리더라도 정확한 판단을 내리려고 한다.", category: 1 },
                { text: "예상되는 결과를 미리 고려해서 행동한다.", category: 1 },

                // 호불호 (H - Heart/Preference)
                { text: "나는 호불호가 분명한 편이다.", category: 2 },
                { text: "내 취향과 다른 것들도 인정하고 받아들인다.", category: 2 },
                { text: "좋아하는 것과 싫어하는 것의 구분이 명확하다.", category: 2 },
                { text: "다른 사람의 취향을 존중하려고 노력한다.", category: 2 },
                { text: "내가 싫어하는 것은 분명히 표현한다.", category: 2 },
                { text: "취향이 다르다고 해서 관계가 나빠지지는 않는다.", category: 2 },
                { text: "내 기준에 맞지 않는 것들을 받아들이기 어렵다.", category: 2 },
                { text: "상대방의 입장을 고려해서 내 의견을 조정한다.", category: 2 },
                { text: "좋고 싫음의 기준이 뚜렷하다.", category: 2 },
                { text: "다양성을 인정하고 포용하려고 한다.", category: 2 },
                { text: "내 감정에 솔직한 편이다.", category: 2 },
                { text: "싫은 것도 참고 견딘다.", category: 2 },
                { text: "내 마음에 들지 않으면 거부감을 표현한다.", category: 2 },
                { text: "상황에 따라 내 감정을 조절한다.", category: 2 },
                { text: "좋아하는 것에는 열정적으로 몰입한다.", category: 2 },
                { text: "상대방의 기분을 고려해서 말한다.", category: 2 },
                { text: "내 취향을 굽히지 않는 편이다.", category: 2 },
                { text: "다른 사람과의 조화를 위해 양보한다.", category: 2 },
                { text: "감정 표현을 자유롭게 하는 편이다.", category: 2 },
                { text: "타인의 감정을 배려해서 행동한다.", category: 2 },

                // K리더십 (K - K-Leadership)
                { text: "그룹에서 자연스럽게 리더 역할을 맡게 된다.", category: 3 },
                { text: "다른 사람들의 의견을 먼저 들어보는 편이다.", category: 3 },
                { text: "내가 앞장서서 일을 추진하는 것을 좋아한다.", category: 3 },
                { text: "팀워크를 중시하고 협력을 이끌어낸다.", category: 3 },
                { text: "결정권이 있을 때 책임감을 느끼고 신중하게 결정한다.", category: 3 },
                { text: "구성원들의 화합을 위해 노력한다.", category: 3 },
                { text: "어려운 상황에서도 방향을 제시한다.", category: 3 },
                { text: "모든 구성원이 참여할 수 있는 분위기를 만든다.", category: 3 },
                { text: "목표 달성을 위해 강력하게 추진한다.", category: 3 },
                { text: "다양한 의견을 조율해서 합의점을 찾는다.", category: 3 },
                { text: "리더로서 솔선수범한다.", category: 3 },
                { text: "구성원들의 능력을 파악하고 적재적소에 배치한다.", category: 3 },
                { text: "힘든 결정도 과감하게 내린다.", category: 3 },
                { text: "팀의 분위기와 사기를 관리한다.", category: 3 },
                { text: "명확한 비전과 방향을 제시한다.", category: 3 },
                { text: "구성원 개개인의 성장을 돕는다.", category: 3 },
                { text: "성과에 대한 책임을 진다.", category: 3 },
                { text: "소통과 공감을 통해 이끌어간다.", category: 3 },
                { text: "변화와 혁신을 주도한다.", category: 3 },
                { text: "포용적 리더십으로 조직을 이끈다.", category: 3 }
            ],
            categories: [
                { name: "도덕심", negative: "융통성", positive: "원칙적", negativeCode: "m", positiveCode: "M" },
                { name: "적시판단", negative: "직관적", positive: "신중한", negativeCode: "j", positiveCode: "J" },
                { name: "호불호", negative: "포용적", positive: "분명한", negativeCode: "h", positiveCode: "H" },
                { name: "K리더십", negative: "협력적", positive: "주도적", negativeCode: "k", positiveCode: "K" }
            ]
        };

        // 질문을 간단한 알고리즘으로 섞기
        function shuffleQuestions(questions) {
            const shuffled = [...questions];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // 각 카테고리별로 5개씩 선택하여 총 20개 질문 구성
        function selectQuestionsForTest() {
            const selectedQuestions = [];
            
            // 각 카테고리별로 질문들을 그룹화
            const questionsByCategory = [[], [], [], []];
            testConfig.questions.forEach(question => {
                questionsByCategory[question.category].push(question);
            });
            
            // 각 카테고리에서 5개씩 랜덤하게 선택
            questionsByCategory.forEach(categoryQuestions => {
                const shuffled = shuffleQuestions(categoryQuestions);
                const selected = shuffled.slice(0, 5); // 상위 5개만 선택
                selectedQuestions.push(...selected);
            });
            
            // 선택된 20개 질문을 다시 섞기
            return shuffleQuestions(selectedQuestions);
        }

        // 테스트용 질문 리스트 생성
        let testQuestions = selectQuestionsForTest();

        // 테스트 상태
        let currentQuestion = 0;
        let answers = [];
        let scores = [0, 0, 0, 0]; // 4개 카테고리별 점수

        // ==========================================
        // 화면 전환 유틸리티 함수
        // ==========================================
        
        function switchScreen(targetScreenId) {
            // 모든 화면 ID 배열
            const allScreens = ['homeScreen', 'testScreen', 'resultScreen'];
            
            // 모든 화면 숨기기
            allScreens.forEach(screenId => {
                const screen = document.getElementById(screenId);
                screen.classList.remove('show');
                screen.classList.add('hidden');
            });
            
            // 대상 화면만 표시
            const targetScreen = document.getElementById(targetScreenId);
            targetScreen.classList.remove('hidden');
            targetScreen.classList.add('show');
            
            // ==========================================
            // 스크롤 위치 초기화 (화면 밀림 방지)
            // ==========================================
            // 전체 페이지 스크롤 초기화
            window.scrollTo(0, 0);
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            // 질문 컨테이너 스크롤 초기화
            const questionsContainer = document.getElementById('questionsContainer');
            if (questionsContainer) {
                questionsContainer.scrollTop = 0;
            }
            // ==========================================
            // 스크롤 위치 초기화 끝
            // ==========================================
        }

        // ==========================================
        // 개발용 테스트 기능 시작
        // ==========================================
        
        function showRandomResult() {
            // 랜덤한 점수 생성 (-3 ~ +3 범위)
            scores = [
                (Math.random() - 0.5) * 6, // 도덕심
                (Math.random() - 0.5) * 6, // 적시판단
                (Math.random() - 0.5) * 6, // 호불호
                (Math.random() - 0.5) * 6  // K리더십
            ];
            
            // 결과 화면으로 전환
            switchScreen('resultScreen');
            showResult();
        }

        // ==========================================
        // 개발용 테스트 기능 끝
        // ==========================================

        function startTest() {
            switchScreen('testScreen');
            showNextQuestion();
        }

        function showNextQuestion() {
            if (currentQuestion >= testQuestions.length) {
                showResult();
                return;
            }

            const question = testQuestions[currentQuestion];
            const questionsContainer = document.getElementById('questionsContainer');
            
            // 새 질문 요소 생성
            const questionItem = document.createElement('div');
            questionItem.className = 'question-item';
            questionItem.innerHTML = `
                <div class="question-container">
                    <div class="question-number">질문 ${currentQuestion + 1}</div>
                    <div class="question-text">${question.text}</div>
                </div>
                
                <div class="option-labels">
                    <span>매우 반대</span>
                    <span>매우 동의</span>
                </div>
                <div class="options-container">
                    <button class="option-btn" data-value="1" data-question="${currentQuestion}">✕</button>
                    <button class="option-btn" data-value="2" data-question="${currentQuestion}"></button>
                    <button class="option-btn" data-value="3" data-question="${currentQuestion}"></button>
                    <button class="option-btn" data-value="4" data-question="${currentQuestion}"></button>
                    <button class="option-btn" data-value="5" data-question="${currentQuestion}"></button>
                    <button class="option-btn" data-value="6" data-question="${currentQuestion}">✓</button>
                </div>
            `;
            
            questionsContainer.appendChild(questionItem);
            
            // 선택지 클릭 이벤트 추가
            const options = questionItem.querySelectorAll('.option-btn');
            options.forEach(btn => {
                btn.onclick = () => selectOption(btn);
            });

            // 진행률 업데이트
            document.getElementById('progressText').textContent = `${currentQuestion + 1} / 20`;
            document.getElementById('progressFill').style.width = `${((currentQuestion + 1) / 20) * 100}%`;
            
            // 스크롤을 새 질문으로 이동
            setTimeout(() => {
                questionItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }

        function selectOption(selectedBtn) {
            const questionIndex = parseInt(selectedBtn.dataset.question);
            const value = parseInt(selectedBtn.dataset.value);
            
            // 같은 질문의 다른 선택지들 비활성화
            const questionItem = selectedBtn.closest('.question-item');
            const allOptions = questionItem.querySelectorAll('.option-btn');
            
            allOptions.forEach(btn => {
                btn.classList.remove('selected');
                btn.style.pointerEvents = 'none';
            });
            
            // 선택된 버튼 활성화
            selectedBtn.classList.add('selected');
            
            // 질문 항목을 answered 상태로 변경
            questionItem.classList.add('answered');
            
            // 답안 저장
            answers[questionIndex] = value;
            
            // 점수 계산
            const question = testQuestions[questionIndex];
            scores[question.category] += value - 3.5;
            
            currentQuestion++;
            
            // 다음 질문 표시 (0.1초 후)
            setTimeout(() => {
                showNextQuestion();
            }, 100);
        }

        function showResult() {
            switchScreen('resultScreen');

            // 성향 코드 생성
            let personalityCode = '';
            scores.forEach((score, index) => {
                const category = testConfig.categories[index];
                personalityCode += score >= 0 ? category.positiveCode : category.negativeCode;
            });
            document.getElementById('personalityCode').textContent = personalityCode.toUpperCase();

            // 성향 바 생성
            const traitBars = document.getElementById('traitBars');
            traitBars.innerHTML = '';

            testConfig.categories.forEach((category, index) => {
                const score = scores[index];
                const normalizedScore = Math.max(-3, Math.min(3, score)); // -3 ~ +3 범위로 제한
                
                const barHTML = `
                    <div class="trait-bar">
                        <div class="trait-labels">
                            <span>${category.negative}</span>
                            <span>${category.positive}</span>
                        </div>
                        <div class="bar-container">
                            <div class="bar-segments">
                                <div class="bar-segment"><div class="segment-fill" data-score="${normalizedScore}" data-segment="-3"></div></div>
                                <div class="bar-segment"><div class="segment-fill" data-score="${normalizedScore}" data-segment="-2"></div></div>
                                <div class="bar-segment"><div class="segment-fill" data-score="${normalizedScore}" data-segment="-1"></div></div>
                                <div class="bar-segment"><div class="segment-fill" data-score="${normalizedScore}" data-segment="1"></div></div>
                                <div class="bar-segment"><div class="segment-fill" data-score="${normalizedScore}" data-segment="2"></div></div>
                                <div class="bar-segment"><div class="segment-fill" data-score="${normalizedScore}" data-segment="3"></div></div>
                            </div>
                            <div class="bar-center"></div>
                        </div>
                    </div>
                `;
                traitBars.innerHTML += barHTML;
            });

            // 바 애니메이션
            setTimeout(() => {
                document.querySelectorAll('.segment-fill').forEach(fill => {
                    const score = parseFloat(fill.dataset.score);
                    const segment = parseInt(fill.dataset.segment);
                    
                    if ((score < 0 && segment < 0 && Math.abs(segment) <= Math.abs(score)) ||
                        (score > 0 && segment > 0 && segment <= score)) {
                        fill.style.width = '100%';
                    }
                });
            }, 500);
        }

        function restartTest() {
            // 테스트 데이터 초기화
            currentQuestion = 0;
            answers = [];
            scores = [0, 0, 0, 0];
            testQuestions = selectQuestionsForTest();
            
            // UI 초기화
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('progressText').textContent = '1 / 20';
            document.getElementById('progressFill').style.width = '0%';
            
            // 홈 화면으로 전환
            switchScreen('homeScreen');
        }

        function shareKakaoTalk() {
            const personalityCode = document.getElementById('personalityCode').textContent || 'MJHK';
            alert(`카카오톡 공유 기능 (결과: ${personalityCode})\n실제 구현 시 카카오 SDK를 사용하세요.`);
        }

        function shareLink() {
            if (navigator.share) {
                navigator.share({
                    title: '철인지수 테스트',
                    text: '나의 철인지수를 확인해보세요!',
                    url: window.location.href
                });
            } else {
                navigator.clipboard.writeText(window.location.href).then(() => {
                    alert('링크가 복사되었습니다!');
                });
            }
        }
    </script>
</body>
</html>
                
